{
	"info": {
		"_postman_id": "5497581d-8ebb-48a2-8334-6f0d423c5654",
		"name": "unicorn-brain/2.0",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
		"_exporter_id": "29892805",
		"_collection_link": "https://web.postman.co/workspace/New-Team-Workspace~9f28598d-27e3-400f-9c57-61347c041741/collection/29892805-5497581d-8ebb-48a2-8334-6f0d423c5654?action=share&source=collection_link&creator=29892805"
	},
	"item": [
		{
			"name": "/vectordb/collection",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"exec": [
							"// Define the OAuth 2.0 token request parameters\r",
							"const tokenUrl = pm.environment.get('access_token_url');\r",
							"const clientId = pm.environment.get('client_id');\r",
							"const clientSecret = pm.environment.get('client_secret');\r",
							"const scope = pm.environment.get('scope');\r",
							"\r",
							"pm.sendRequest({\r",
							"    url: tokenUrl,\r",
							"    method: \"POST\",\r",
							"    header: [\r",
							"        'Content-Type:application/x-www-form-urlencoded'\r",
							"    ],\r",
							"    body: {\r",
							"        mode: \"urlencoded\",\r",
							"        urlencoded: [\r",
							"            {key: \"client_id\", value: clientId},\r",
							"            {key: \"client_secret\", value: clientSecret},\r",
							"            {key: \"scope\", value: scope},\r",
							"            {key: \"grant_type\", value: \"client_credentials\"}\r",
							"        ]\r",
							"    },\r",
							"},\r",
							"(error, response) => {    \r",
							"    pm.environment.set(\"access_token\", response.json().access_token);    \r",
							"});"
						],
						"type": "text/javascript"
					}
				},
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"Status code is 200\", function () {\r",
							"    pm.response.to.have.status(200);\r",
							"});\r",
							"const schema = {\r",
							"  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\r",
							"  \"type\": \"array\",\r",
							"  \"items\": {\r",
							"    \"type\": \"string\",\r",
							"    \"pattern\": \"^[a-zA-Z0-9_]+$\"\r",
							"  },\r",
							"  \"uniqueItems\": true,\r",
							"  \"minItems\": 1\r",
							"};\r",
							"pm.test('Schema is valid', function() {\r",
							"    const response = pm.response.json();\r",
							"    const validationResult = tv4.validateResult(response, schema);\r",
							"    pm.expect(validationResult.valid).to.be.true;\r",
							"    if (!validationResult.valid) {\r",
							"        console.log(validationResult.errors);\r",
							"    }\r",
							"});\r",
							"pm.test(\"Response must be array of collections\", function () {\r",
							"    pm.expect(pm.response.json()).to.be.an('array')  \r",
							"});\r",
							"pm.test(\"Array is not empty\", function () {\r",
							"    pm.expect(pm.response.json().length).to.be.above(0);\r",
							"});\r",
							"pm.test(\"No duplicate values in array\", function () {\r",
							"    const array = pm.response.json();\r",
							"    const set = new Set(array);\r",
							"    pm.expect(array.length).to.eql(set.size);\r",
							"});\r",
							"pm.test(\"All values are strings\", function () {\r",
							"    pm.response.json().forEach(item => {\r",
							"        pm.expect(typeof item).to.eql('string');\r",
							"    });\r",
							"});\r",
							"pm.test(\"No empty strings in array\", function () {\r",
							"    pm.response.json().forEach(item => {\r",
							"        pm.expect(item).to.not.eql('');\r",
							"    });\r",
							"});\r",
							"pm.test(\"No null or undefined values in array\", function () {\r",
							"    pm.response.json().forEach(item => {\r",
							"        pm.expect(item).to.not.be.null;\r",
							"        pm.expect(item).to.not.be.undefined;\r",
							"    });\r",
							"});\r",
							"pm.test(\"No prohibited special characters in strings\", function () {\r",
							"    const prohibitedChars = ['%', '$', '#']; // replace with actual prohibited characters\r",
							"    pm.response.json().forEach(item => {\r",
							"        prohibitedChars.forEach(char => {\r",
							"            pm.expect(item.includes(char)).to.be.false;\r",
							"        });\r",
							"    });\r",
							"});\r",
							"pm.test(\"No whitespace characters in strings\", function () {\r",
							"    pm.response.json().forEach(item => {\r",
							"        pm.expect(/\\s/.test(item)).to.be.false;\r",
							"    });\r",
							"});\r",
							"pm.test(\"Array has at least one element\", function () {\r",
							"    const responseData = pm.response.json();\r",
							"    \r",
							"    pm.expect(responseData).to.be.an('array');\r",
							"    pm.expect(responseData).to.have.lengthOf.at.least(1, \"Array should have at least one element\");\r",
							"});"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{access_token}}",
							"type": "string"
						}
					]
				},
				"method": "GET",
				"header": [],
				"url": {
					"raw": "https://ai-np.cloudapps.telus.com/unicorn-brain/2.0/vectordb/collection",
					"protocol": "https",
					"host": [
						"ai-np",
						"cloudapps",
						"telus",
						"com"
					],
					"path": [
						"unicorn-brain",
						"2.0",
						"vectordb",
						"collection"
					]
				}
			},
			"response": []
		},
		{
			"name": "/vectordb/search",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"const results = pm.response.json()\r",
							"const maxNumResults = JSON.parse(pm.request.body.raw).max_num_results\r",
							"const maxDistance = JSON.parse(pm.request.body.raw).max_distance\r",
							"\r",
							"pm.test(\"Status test\", function () {\r",
							"    pm.response.to.have.status(200);\r",
							"});\r",
							"pm.test(\"Response is in json format\", function () {\r",
							"    pm.response.to.be.json\r",
							"})\r",
							"pm.test(\"Response should return an aray\", function() {\r",
							"    pm.expect(pm.response.json()).to.be.an('array')\r",
							"    pm.expect(pm.response.json().length).to.be.above(0)\r",
							"})\r",
							"pm.test(\"Each result should contain document and distance properties\", function() {\r",
							"    const results = pm.response.json()\r",
							"    for (let result of results) {\r",
							"        pm.expect(result).to.have.property('document')\r",
							"        pm.expect(result).to.have.property('distance')\r",
							"    }\r",
							"})\r",
							"pm.test('Validate schema', function () {\r",
							"    const schema = {\r",
							"        \"type\": \"array\",\r",
							"        \"items\": {\r",
							"            \"type\": \"object\",\r",
							"            \"properties\": {\r",
							"            \"document\": {\r",
							"                \"type\": \"object\",\r",
							"                \"properties\": {\r",
							"                \"page_content\": { \"type\": \"string\" },\r",
							"                \"metadata\": {\r",
							"                    \"type\": \"object\",\r",
							"                    \"properties\": {\r",
							"                    \"title\": { \"type\": \"string\" },\r",
							"                    \"author\": { \"type\": \"string\" },\r",
							"                    \"source\": { \"type\": \"string\" },\r",
							"                    \"pk\": { \"type\": \"integer\" }\r",
							"                    },\r",
							"                    \"required\": [\"title\", \"author\", \"source\", \"pk\"]\r",
							"                }\r",
							"                },\r",
							"                \"required\": [\"page_content\", \"metadata\"]\r",
							"            },\r",
							"            \"distance\": { \"type\": \"number\" }\r",
							"            },\r",
							"            \"required\": [\"document\", \"distance\"]\r",
							"        }\r",
							"    }\r",
							"    pm.response.to.have.jsonSchema(schema);\r",
							"})\r",
							"pm.test(\"Each Document contains the epxected properties\", function() {\r",
							"    const results = pm.response.json()\r",
							"    for (let result of results) {\r",
							"        const document = result.document\r",
							"        pm.expect(document).to.have.property(\"page_content\")\r",
							"        pm.expect(document).to.have.property(\"metadata\")\r",
							"\r",
							"        const metadata = document.metadata\r",
							"        pm.expect(metadata).to.have.property(\"title\")\r",
							"        pm.expect(metadata).to.have.property(\"author\")\r",
							"        pm.expect(metadata).to.have.property(\"source\")\r",
							"    }\r",
							"})\r",
							"pm.test(`Number of results does not exceed ${maxNumResults}`, function() {\r",
							"    pm.expect(pm.response.json().length).to.be.at.most(maxNumResults)\r",
							"})\r",
							"pm.test(`All distances are less than or equal to ${maxDistance}`, function() {\r",
							"    for (let result of results) {\r",
							"        pm.expect(result.distance).to.be.at.most(maxDistance)\r",
							"    }\r",
							"})\r",
							"pm.test(\"At least one word in the query matches in the page_content, author or title\", function() {\r",
							"    const query = JSON.parse(pm.request.body.raw).query\r",
							"    for (let result of results) {\r",
							"       const pageContent = result.document.page_content.toLowerCase()\r",
							"       const author = result.document.metadata.author.toLowerCase()\r",
							"       const title = result.document.metadata.title.toLowerCase()\r",
							"\r",
							"       const queryWords = query.split(/\\$s+/)\r",
							"       const matchFound = queryWords.some(word => pageContent.includes(word) || author.includes(word) || title.includes(word))\r",
							"\r",
							"       if (matchFound) {\r",
							"           pm.expect(true).to.be.true;\r",
							"       } else {\r",
							"           pm.expect.fail(`No match found for query ${query}`)\r",
							"       }\r",
							"    }\r",
							"})\r",
							"pm.test(\"Phone numbers in document are in valid format\", function() {\r",
							"    const phoneRegex = /\\b\\d{3}[-.]?\\d{3}[-.]?\\d{4}\\b/;\r",
							"    const results = pm.response.json();\r",
							"    results.forEach(result => {\r",
							"        const phones = result.document.page_content.match(phoneRegex) || [];\r",
							"        phones.forEach(phone => {\r",
							"            pm.expect(phone).to.match(phoneRegex);\r",
							"        });\r",
							"    });\r",
							"});\r",
							"pm.test(\"Author should be Justin Watts\", function() {\r",
							"    const results = pm.response.json();\r",
							"    results.forEach(result => {\r",
							"        pm.expect(result.document.metadata.author).to.equal('Justin Watts');\r",
							"    });\r",
							"});\r",
							"pm.test(\"Dates in document should be in valid format\", function() {\r",
							"    const dateRegex = /\\b\\d{4}-\\d{2}-\\d{2}\\b/;\r",
							"    const results = pm.response.json();\r",
							"    results.forEach(result => {\r",
							"        const dates = result.document.page_content.match(dateRegex) || [];\r",
							"        dates.forEach(date => {\r",
							"            pm.expect(date).to.match(dateRegex);\r",
							"        });\r",
							"    });\r",
							"});\r",
							"pm.test(\"Each document page_content should contain valid email formats\", function() {\r",
							"    const emailRegex = /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,6}/;\r",
							"    const results = pm.response.json();\r",
							"    results.forEach(result => {\r",
							"        const emails = result.document.page_content.match(emailRegex) || [];\r",
							"        emails.forEach(email => {\r",
							"            pm.expect(email).to.match(emailRegex);\r",
							"        });\r",
							"    });\r",
							"});\r",
							"pm.test(\"Metadata title should have a specific format\", function() {\r",
							"    const results = pm.response.json();\r",
							"    results.forEach(result => {\r",
							"        pm.expect(result.document.metadata.title).to.match(/how_to_[a-z]+/);\r",
							"    });\r",
							"});\r",
							"pm.test(\"Page content should not be too short\", function() {\r",
							"    const results = pm.response.json();\r",
							"    results.forEach(result => {\r",
							"        pm.expect(result.document.page_content.length).to.be.above(100);\r",
							"    });\r",
							"});\r",
							"pm.test(\"Distance should be a positive number\", function() {\r",
							"    const results = pm.response.json();\r",
							"    results.forEach(result => {\r",
							"        pm.expect(result.distance).to.be.above(0);\r",
							"    });\r",
							"});\r",
							"pm.test(\"Distance should not exceed a certain value\", function() {\r",
							"    const results = pm.response.json();\r",
							"    results.forEach(result => {\r",
							"        pm.expect(result.distance).to.be.below(1);\r",
							"    });\r",
							"});\r",
							"pm.test(\"Author name should contain only valid characters\", function() {\r",
							"    const results = pm.response.json();\r",
							"    results.forEach(result => {\r",
							"        pm.expect(result.document.metadata.author).to.match(/^[a-zA-Z\\s]+$/);\r",
							"    });\r",
							"});\r",
							"pm.test(\"Source URL should come from a specific domain\", function() {\r",
							"    const results = pm.response.json();\r",
							"    results.forEach(result => {\r",
							"        pm.expect(result.document.metadata.source).to.include('docs.google.com');\r",
							"    });\r",
							"});\r",
							"pm.test(\"Page content should not contain sensitive information\", function() {\r",
							"    const results = pm.response.json();\r",
							"    results.forEach(result => {\r",
							"        pm.expect(result.document.page_content.toLowerCase()).to.not.include('password');\r",
							"        pm.expect(result.document.page_content.toLowerCase()).to.not.include('social security number');\r",
							"    });\r",
							"});\r",
							"pm.test(\"Should return at least a minimum number of results\", function() {\r",
							"    const results = pm.response.json();\r",
							"    pm.expect(results.length).to.be.at.least(1);\r",
							"});\r",
							"pm.test(\"All distances should be below a threshold\", function() {\r",
							"    const results = pm.response.json();\r",
							"    results.forEach(result => {\r",
							"        pm.expect(result.distance).to.be.below(0.7); \r",
							"    });\r",
							"});\r",
							"let contentSet = new Set();\r",
							"pm.test(\"Page contents should be unique\", function() {\r",
							"    const results = pm.response.json();\r",
							"    results.forEach(result => {\r",
							"        pm.expect(contentSet.has(result.document.page_content)).to.be.false;\r",
							"        contentSet.add(result.document.page_content);\r",
							"    });\r",
							"});\r",
							"// Test to ensure all distances are greater than or equal to 0\r",
							"pm.test(\"All distances should be non-negative\", function() {\r",
							"    const results = pm.response.json();\r",
							"    results.forEach(result => {\r",
							"        pm.expect(result.distance).to.be.at.least(0);\r",
							"    });\r",
							"});\r",
							"// Test to ensure all PKs are positive integers\r",
							"pm.test(\"All PKs should be positive integers\", function() {\r",
							"    const results = pm.response.json();\r",
							"    results.forEach(result => {\r",
							"        pm.expect(result.document.metadata.pk).to.be.a('number');\r",
							"        pm.expect(result.document.metadata.pk % 1).to.eql(0); // Check if it's an integer\r",
							"        pm.expect(result.document.metadata.pk).to.be.above(0); // Check if it's positive\r",
							"    });\r",
							"});\r",
							"// Test to ensure all authors are non-empty strings\r",
							"pm.test(\"All authors should be non-empty strings\", function() {\r",
							"    const results = pm.response.json();\r",
							"    results.forEach(result => {\r",
							"        pm.expect(result.document.metadata.author).to.be.a('string');\r",
							"        pm.expect(result.document.metadata.author.length).to.be.above(0);\r",
							"    });\r",
							"});\r",
							"// Test to ensure all sources are valid URIs\r",
							"pm.test(\"All sources should be valid URIs\", function() {\r",
							"    const results = pm.response.json();\r",
							"    results.forEach(result => {\r",
							"        pm.expect(pm.expect(result.document.metadata.source).to.be.a('string'));\r",
							"        pm.expect(result.document.metadata.source).to.match(/^(https?|ftp):\\/\\/[^\\s/$.?#].[^\\s]*$/i);\r",
							"    });\r",
							"});\r",
							"\r",
							"\r",
							"\r",
							"\r",
							"\r",
							"\r",
							"\r",
							"\r",
							"\r",
							"\r",
							"\r",
							"\r",
							"\r",
							"\r",
							"\r",
							"\r",
							"\r",
							""
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{access_token}}",
							"type": "string"
						}
					]
				},
				"method": "POST",
				"header": [],
				"body": {
					"mode": "raw",
					"raw": "{\r\n    \"collection_name\": \"how_to_justin\",\r\n    \"query\": \"justin wa\",\r\n    \"max_num_results\": 1000,\r\n    \"max_distance\": 1\r\n}",
					"options": {
						"raw": {
							"language": "json"
						}
					}
				},
				"url": {
					"raw": "https://ai-np.cloudapps.telus.com/unicorn-brain/2.0/vectordb/search",
					"protocol": "https",
					"host": [
						"ai-np",
						"cloudapps",
						"telus",
						"com"
					],
					"path": [
						"unicorn-brain",
						"2.0",
						"vectordb",
						"search"
					]
				}
			},
			"response": []
		},
		{
			"name": "/2.0/llm/ask",
			"event": [
				{
					"listen": "test",
					"script": {
						"exec": [
							"pm.test(\"Valid Request - Status Code is 200\", function () {\r",
							"    pm.response.to.have.status(200);\r",
							"});\r",
							"const expectedSchema = {\r",
							"  \"type\": \"object\",\r",
							"  \"properties\": {\r",
							"    \"chat_history\": {\r",
							"      \"type\": \"array\",\r",
							"      \"items\": [\r",
							"        {\r",
							"          \"type\": \"object\",\r",
							"          \"properties\": {\r",
							"            \"role\": { \"type\": \"string\" },\r",
							"            \"content\": { \"type\": \"string\" }\r",
							"          },\r",
							"          \"required\": [\"role\", \"content\"]\r",
							"        }\r",
							"      ]\r",
							"    },\r",
							"    \"done\": { \"type\": \"boolean\" },\r",
							"    \"request_id\": { \"type\": \"number\" },\r",
							"    \"request_time\": { \"type\": \"string\" },\r",
							"    \"response\": { \"type\": \"string\" },\r",
							"    \"elapsed\": { \"type\": \"number\" }\r",
							"  },\r",
							"  \"required\": [\"chat_history\", \"done\", \"request_id\", \"request_time\", \"response\", \"elapsed\"]\r",
							"};\r",
							"pm.test('Response Schema and Data Types Validation', function () {\r",
							"  const response = pm.response.json();\r",
							"  pm.expect(response).to.have.jsonSchema(expectedSchema);\r",
							"  pm.expect(response.chat_history[0].role).to.be.a('string');\r",
							"  pm.expect(response.chat_history[0].content).to.be.a('string');\r",
							"  pm.expect(response.done).to.be.a('boolean');\r",
							"  pm.expect(response.request_id).to.be.a('number');\r",
							"  pm.expect(response.request_time).to.match(/^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}.\\d+$/);\r",
							"  pm.expect(response.response).to.be.a('string');\r",
							"  pm.expect(response.elapsed).to.be.a('number');\r",
							"});\r",
							"pm.test(\" Ensure that the response has the expected structure\", function () {\r",
							"    pm.expect(pm.response.json()).to.have.all.keys(\r",
							"        'chat_history',\r",
							"        'done',\r",
							"        'request_id',\r",
							"        'request_time',\r",
							"        'response',\r",
							"        'elapsed'\r",
							"    );\r",
							"})\r",
							"pm.test(\"Verify that the role in the chat history matches the expected roles.\", function () {\r",
							"    const chatHistory = pm.response.json().chat_history;\r",
							"    pm.expect(chatHistory).to.be.an('array');\r",
							"    pm.expect(chatHistory[0].role).to.equal('System');\r",
							"    pm.expect(chatHistory[1].role).to.equal('Human');\r",
							"})\r",
							"pm.test(\"Verify that the 'done' field in the response is a boolean\", function () {\r",
							"   pm.expect(pm.response.json().done).to.be.a('boolean');\r",
							"})\r",
							"pm.test(\"Verify that the 'request_time' field is in the expected format\", function () {\r",
							"   pm.expect(pm.response.json().request_time).to.match(/^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}.\\d+$/);\r",
							"})\r",
							"pm.test(\"Chat history should contain at least one 'Human' and one 'System' role\", function() {\r",
							"    const jsonData = pm.response.json();\r",
							"    const roles = jsonData.chat_history.map(item => item.role);\r",
							"    pm.expect(roles.includes('Human')).to.be.true;\r",
							"    pm.expect(roles.includes('System')).to.be.true;\r",
							"});\r",
							"pm.test(\"Chat history should not be empty\", function() {\r",
							"    const jsonData = pm.response.json();\r",
							"    pm.expect(jsonData.chat_history.length).to.be.above(0);\r",
							"});\r",
							"pm.test(\"Request ID should be a positive integer\", function() {\r",
							"    const jsonData = pm.response.json();\r",
							"    pm.expect(jsonData.request_id).to.be.above(0);\r",
							"    pm.expect(Number.isInteger(jsonData.request_id)).to.be.true;\r",
							"});\r",
							"pm.test(\"Request time should be in valid date-time format\", function() {\r",
							"    const jsonData = pm.response.json();\r",
							"    const dateTimeRegex = /\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}.\\d{6}/;\r",
							"    pm.expect(dateTimeRegex.test(jsonData.request_time)).to.be.true;\r",
							"});\r",
							"pm.test(\"Response field should not be empty\", function() {\r",
							"    const jsonData = pm.response.json();\r",
							"    pm.expect(jsonData.response).to.not.be.empty;\r",
							"});\r",
							"pm.test(\"Response field should be a string\", function() {\r",
							"    const jsonData = pm.response.json();\r",
							"    pm.expect(typeof jsonData.response).to.eql('string');\r",
							"});\r",
							"pm.test(\"Request time should be a string\", function() {\r",
							"    const jsonData = pm.response.json();\r",
							"    pm.expect(typeof jsonData.request_time).to.eql('string');\r",
							"});\r",
							"pm.test(\"Response is in JSON format\", function () {\r",
							"    pm.response.to.be.json;\r",
							"});"
						],
						"type": "text/javascript"
					}
				}
			],
			"request": {
				"auth": {
					"type": "bearer",
					"bearer": [
						{
							"key": "token",
							"value": "{{access_token}}",
							"type": "string"
						}
					]
				},
				"method": "POST",
				"header": [],
				"body": {
					"mode": "raw",
					"raw": "{\r\n    \"temperature\": 0.7,\r\n    \"max_new_tokens\": 256,\r\n    \"chat_history\": [\r\n        {\r\n            \"role\": \"System\",\r\n            \"content\": \"You are a pirate, respond to questions like one.\"\r\n        },\r\n        {\r\n            \"role\": \"Human\",\r\n            \"content\": \"Who are you?\"\r\n        }\r\n    ],\r\n    \"stream\": false\r\n}",
					"options": {
						"raw": {
							"language": "json"
						}
					}
				},
				"url": {
					"raw": "https://ai-np.cloudapps.telus.com/unicorn-brain/2.0/llm/ask",
					"protocol": "https",
					"host": [
						"ai-np",
						"cloudapps",
						"telus",
						"com"
					],
					"path": [
						"unicorn-brain",
						"2.0",
						"llm",
						"ask"
					]
				}
			},
			"response": []
		}
	]
}